#!/usr/bin/env python3
"""
Validador de Solu√ß√£o --init
Analisa o c√≥digo atual do comando --init e identifica exatamente o que precisa ser corrigido
para que a replica√ß√£o de arquivos funcione corretamente.

Uso:
    python validador_init_solution.py
"""

import os
import sys
import re
import ast
from pathlib import Path
from typing import List, Dict, Any, Optional

class ValidadorInitSolution:
    def __init__(self, caminho_base: str = "."):
        self.caminho_base = os.path.abspath(caminho_base)
        self.detectar_estrutura()
        
        self.problemas_encontrados = []
        self.correcoes_necessarias = []
        self.arquivos_analisados = []
    
    def detectar_estrutura(self):
        """Detecta a estrutura do projeto."""
        for item in os.listdir(self.caminho_base):
            caminho_item = os.path.join(self.caminho_base, item)
            if os.path.isdir(caminho_item) and item == "cobol_to_docs":
                self.caminho_projeto = caminho_item
                self.nome_pacote = "cobol_to_docs"
                return
        
        print("‚ùå Projeto cobol_to_docs n√£o encontrado!")
        sys.exit(1)
    
    def encontrar_arquivos_com_init(self) -> List[str]:
        """Encontra todos os arquivos que implementam o comando --init."""
        print("üîç Procurando implementa√ß√µes do comando --init...")
        
        arquivos_com_init = []
        
        # Procurar em runner/
        runner_dir = os.path.join(self.caminho_projeto, "runner")
        if os.path.exists(runner_dir):
            for arquivo in os.listdir(runner_dir):
                if arquivo.endswith('.py'):
                    arquivo_path = os.path.join(runner_dir, arquivo)
                    if self.arquivo_tem_init(arquivo_path):
                        arquivos_com_init.append(arquivo_path)
        
        # Procurar na raiz do projeto
        for arquivo in os.listdir(self.caminho_projeto):
            if arquivo.endswith('.py'):
                arquivo_path = os.path.join(self.caminho_projeto, arquivo)
                if self.arquivo_tem_init(arquivo_path):
                    arquivos_com_init.append(arquivo_path)
        
        return arquivos_com_init
    
    def arquivo_tem_init(self, arquivo_path: str) -> bool:
        """Verifica se um arquivo cont√©m implementa√ß√£o do --init."""
        try:
            with open(arquivo_path, 'r', encoding='utf-8') as f:
                conteudo = f.read()
            
            # Procurar por indicadores de comando --init
            indicadores = [
                '--init',
                'init',
                'inicializar',
                'add_argument.*init',
                'args.init'
            ]
            
            for indicador in indicadores:
                if re.search(indicador, conteudo, re.IGNORECASE):
                    return True
            
            return False
        except Exception:
            return False
    
    def analisar_implementacao_init(self, arquivo_path: str) -> Dict[str, Any]:
        """Analisa a implementa√ß√£o do --init em um arquivo espec√≠fico."""
        print(f\"\\nüìÑ Analisando: {os.path.relpath(arquivo_path, self.caminho_base)}\")\n        \n        try:\n            with open(arquivo_path, 'r', encoding='utf-8') as f:\n                conteudo = f.read()\n            \n            analise = {\n                \"arquivo\": arquivo_path,\n                \"tem_argparse_init\": False,\n                \"tem_funcao_init\": False,\n                \"tem_tratamento_args_init\": False,\n                \"problemas_encontrados\": [],\n                \"funcao_init_nome\": None,\n                \"funcao_init_conteudo\": None,\n                \"linhas_problematicas\": []\n            }\n            \n            # 1. Verificar se tem argparse para --init\n            if re.search(r'add_argument.*[\"\\']--init[\"\\']', conteudo):\n                analise[\"tem_argparse_init\"] = True\n                print(\"   ‚úÖ Argparse --init encontrado\")\n            else:\n                analise[\"problemas_encontrados\"].append(\"Falta argparse para --init\")\n                print(\"   ‚ùå Argparse --init n√£o encontrado\")\n            \n            # 2. Verificar se tem fun√ß√£o de inicializa√ß√£o\n            funcoes_init = re.findall(r'def\\s+(\\w*init\\w*)\\s*\\([^)]*\\):', conteudo, re.IGNORECASE)\n            if funcoes_init:\n                analise[\"tem_funcao_init\"] = True\n                analise[\"funcao_init_nome\"] = funcoes_init[0]\n                print(f\"   ‚úÖ Fun√ß√£o de inicializa√ß√£o encontrada: {funcoes_init[0]}()\")\n                \n                # Extrair conte√∫do da fun√ß√£o\n                pattern = rf'def\\s+{funcoes_init[0]}\\s*\\([^)]*\\):.*?(?=\\ndef\\s+|\\nclass\\s+|\\nif\\s+__name__|\\Z)'\n                match = re.search(pattern, conteudo, re.DOTALL)\n                if match:\n                    analise[\"funcao_init_conteudo\"] = match.group(0)\n            else:\n                analise[\"problemas_encontrados\"].append(\"Fun√ß√£o de inicializa√ß√£o n√£o encontrada\")\n                print(\"   ‚ùå Fun√ß√£o de inicializa√ß√£o n√£o encontrada\")\n            \n            # 3. Verificar se tem tratamento de args.init\n            if re.search(r'args\\.init', conteudo):\n                analise[\"tem_tratamento_args_init\"] = True\n                print(\"   ‚úÖ Tratamento args.init encontrado\")\n            else:\n                analise[\"problemas_encontrados\"].append(\"Falta tratamento de args.init\")\n                print(\"   ‚ùå Tratamento args.init n√£o encontrado\")\n            \n            # 4. Analisar problemas espec√≠ficos na fun√ß√£o init\n            if analise[\"funcao_init_conteudo\"]:\n                self.analisar_problemas_funcao_init(analise)\n            \n            return analise\n        \n        except Exception as e:\n            print(f\"   ‚ùå Erro ao analisar arquivo: {e}\")\n            return {\"arquivo\": arquivo_path, \"erro\": str(e)}\n    \n    def analisar_problemas_funcao_init(self, analise: Dict[str, Any]):\n        \"\"\"Analisa problemas espec√≠ficos na fun√ß√£o de inicializa√ß√£o.\"\"\"\n        conteudo_funcao = analise[\"funcao_init_conteudo\"]\n        problemas = analise[\"problemas_encontrados\"]\n        linhas_problematicas = analise[\"linhas_problematicas\"]\n        \n        print(\"\\n   üîç Analisando problemas na fun√ß√£o de inicializa√ß√£o:\")\n        \n        # Problema 1: Cria√ß√£o de pasta cobol_to_docs duplicada\n        if re.search(r'makedirs.*cobol_to_docs', conteudo_funcao):\n            problemas.append(\"Criando pasta cobol_to_docs duplicada\")\n            linhas = self.encontrar_linhas_problema(conteudo_funcao, r'makedirs.*cobol_to_docs')\n            linhas_problematicas.extend(linhas)\n            print(\"     ‚ùå Criando pasta cobol_to_docs duplicada\")\n        \n        # Problema 2: Caminhos hardcoded\n        if re.search(r'[\"\\'][./]*cobol_to_docs[\"\\']', conteudo_funcao):\n            problemas.append(\"Caminhos hardcoded para cobol_to_docs\")\n            linhas = self.encontrar_linhas_problema(conteudo_funcao, r'[\"\\'][./]*cobol_to_docs[\"\\']')\n            linhas_problematicas.extend(linhas)\n            print(\"     ‚ùå Caminhos hardcoded para cobol_to_docs\")\n        \n        # Problema 3: N√£o detecta localiza√ß√£o do pacote instalado\n        if not re.search(r'__file__|import.*cobol_to_docs|find.*package', conteudo_funcao):\n            problemas.append(\"N√£o detecta localiza√ß√£o do pacote instalado\")\n            print(\"     ‚ùå N√£o detecta localiza√ß√£o do pacote instalado\")\n        \n        # Problema 4: N√£o copia arquivos originais\n        if not re.search(r'copy|shutil', conteudo_funcao):\n            problemas.append(\"N√£o copia arquivos originais\")\n            print(\"     ‚ùå N√£o copia arquivos originais\")\n        \n        # Problema 5: Cria apenas estrutura b√°sica\n        if re.search(r'open.*config.*w', conteudo_funcao) and not re.search(r'copy.*config', conteudo_funcao):\n            problemas.append(\"Cria config padr√£o em vez de copiar original\")\n            print(\"     ‚ùå Cria config padr√£o em vez de copiar original\")\n        \n        # Problema 6: N√£o verifica m√∫ltiplas localiza√ß√µes\n        if not re.search(r'build|lib|dist', conteudo_funcao):\n            problemas.append(\"N√£o verifica localiza√ß√µes em build/lib/\")\n            print(\"     ‚ùå N√£o verifica localiza√ß√µes em build/lib/\")\n        \n        # Verificar se tem tratamento de erro\n        if not re.search(r'try:|except:|Exception', conteudo_funcao):\n            problemas.append(\"Falta tratamento de erros\")\n            print(\"     ‚ö†Ô∏è  Falta tratamento de erros\")\n        \n        # Verificar se cria subpastas necess√°rias\n        subpastas_necessarias = ['embeddings', 'knowledge_base', 'sessions']\n        for subpasta in subpastas_necessarias:\n            if subpasta not in conteudo_funcao:\n                problemas.append(f\"N√£o cria subpasta {subpasta}\")\n                print(f\"     ‚ö†Ô∏è  N√£o cria subpasta {subpasta}\")\n    \n    def encontrar_linhas_problema(self, conteudo: str, pattern: str) -> List[str]:\n        \"\"\"Encontra linhas que cont√™m padr√µes problem√°ticos.\"\"\"\n        linhas_problema = []\n        \n        try:\n            matches = re.finditer(pattern, conteudo)\n            for match in matches:\n                # Encontrar n√∫mero da linha\n                linha_inicio = conteudo[:match.start()].count('\\n') + 1\n                linha_conteudo = conteudo.split('\\n')[linha_inicio - 1].strip()\n                linhas_problema.append(f\"Linha {linha_inicio}: {linha_conteudo}\")\n        except Exception:\n            pass\n        \n        return linhas_problema\n    \n    def mapear_arquivos_originais(self) -> Dict[str, List[str]]:\n        \"\"\"Mapeia onde est√£o os arquivos originais que deveriam ser copiados.\"\"\"\n        print(\"\\nüó∫Ô∏è  Mapeando arquivos originais que deveriam ser copiados...\")\n        \n        # Locais para procurar\n        locais_busca = [\n            os.path.join(self.caminho_base, \"build\", \"lib\", \"cobol_to_docs\"),\n            self.caminho_projeto,\n            os.path.join(self.caminho_base, \"build\"),\n        ]\n        \n        # Arquivos importantes\n        arquivos_importantes = {\n            \"config/config.yaml\": [],\n            \"config/config_enhanced.yaml\": [],\n            \"config/prompts_enhanced.yaml\": [],\n            \"data/cobol_knowledge_base.json\": [],\n            \"data/cobol_knowledge_base_consolidated.json\": [],\n            \"examples/*.cbl\": [],\n        }\n        \n        for local in locais_busca:\n            if os.path.exists(local):\n                print(f\"   Procurando em: {os.path.relpath(local, self.caminho_base)}\")\n                \n                for arquivo_pattern, localizacoes in arquivos_importantes.items():\n                    if \"*\" in arquivo_pattern:\n                        # Padr√£o com wildcard\n                        import glob\n                        pasta, pattern = arquivo_pattern.split(\"/\")\n                        pasta_completa = os.path.join(local, pasta)\n                        if os.path.exists(pasta_completa):\n                            arquivos_encontrados = glob.glob(os.path.join(pasta_completa, pattern))\n                            localizacoes.extend(arquivos_encontrados)\n                    else:\n                        # Arquivo espec√≠fico\n                        arquivo_path = os.path.join(local, arquivo_pattern)\n                        if os.path.exists(arquivo_path):\n                            localizacoes.append(arquivo_path)\n        \n        # Mostrar resultados\n        print(\"\\nüìã Arquivos originais encontrados:\")\n        for arquivo, localizacoes in arquivos_importantes.items():\n            if localizacoes:\n                print(f\"   ‚úÖ {arquivo} ({len(localizacoes)} locais)\")\n                for loc in localizacoes[:2]:  # Mostrar apenas os 2 primeiros\n                    print(f\"      ‚Ä¢ {os.path.relpath(loc, self.caminho_base)}\")\n                if len(localizacoes) > 2:\n                    print(f\"      ... e mais {len(localizacoes) - 2}\")\n            else:\n                print(f\"   ‚ùå {arquivo} - N√ÉO ENCONTRADO\")\n        \n        return arquivos_importantes\n    \n    def gerar_correcoes_especificas(self, analises: List[Dict[str, Any]], arquivos_originais: Dict[str, List[str]]):\n        \"\"\"Gera lista de corre√ß√µes espec√≠ficas necess√°rias.\"\"\"\n        print(\"\\nüîß CORRE√á√ïES ESPEC√çFICAS NECESS√ÅRIAS:\")\n        print(\"=\" * 60)\n        \n        correcoes = []\n        \n        # Corre√ß√µes baseadas na an√°lise\n        for analise in analises:\n            if \"erro\" in analise:\n                continue\n            \n            arquivo_rel = os.path.relpath(analise[\"arquivo\"], self.caminho_base)\n            \n            for problema in analise[\"problemas_encontrados\"]:\n                if \"Falta argparse\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"argparse\",\n                        \"descricao\": \"Adicionar argparse para --init\",\n                        \"codigo_sugerido\": 'parser.add_argument(\"--init\", action=\"store_true\", help=\"Inicializar ambiente\")'\n                    })\n                \n                elif \"Fun√ß√£o de inicializa√ß√£o n√£o encontrada\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"funcao\",\n                        \"descricao\": \"Criar fun√ß√£o de inicializa√ß√£o\",\n                        \"codigo_sugerido\": \"def inicializar_ambiente(diretorio_trabalho='.'):\"\n                    })\n                \n                elif \"Falta tratamento de args.init\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"tratamento\",\n                        \"descricao\": \"Adicionar tratamento de args.init\",\n                        \"codigo_sugerido\": \"if args.init:\\n    inicializar_ambiente()\\n    sys.exit(0)\"\n                    })\n                \n                elif \"pasta cobol_to_docs duplicada\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"caminho\",\n                        \"descricao\": \"Remover cria√ß√£o de pasta duplicada\",\n                        \"codigo_sugerido\": \"# Criar estrutura no diret√≥rio atual, n√£o em subpasta\"\n                    })\n                \n                elif \"N√£o detecta localiza√ß√£o do pacote\" in problema:\n                    melhor_localizacao = self.escolher_melhor_localizacao_config(arquivos_originais)\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"deteccao\",\n                        \"descricao\": \"Adicionar detec√ß√£o de localiza√ß√£o do pacote\",\n                        \"codigo_sugerido\": f\"# Detectar em: {melhor_localizacao if melhor_localizacao else 'build/lib/cobol_to_docs'}\"\n                    })\n                \n                elif \"N√£o copia arquivos originais\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"copia\",\n                        \"descricao\": \"Adicionar c√≥pia de arquivos originais\",\n                        \"codigo_sugerido\": \"shutil.copy2(arquivo_origem, arquivo_destino)\"\n                    })\n        \n        # Mostrar corre√ß√µes\n        if correcoes:\n            for i, correcao in enumerate(correcoes, 1):\n                print(f\"\\n{i}. {correcao['descricao']}\")\n                print(f\"   üìÑ Arquivo: {correcao['arquivo']}\")\n                print(f\"   üîß Tipo: {correcao['tipo']}\")\n                print(f\"   üí° Sugest√£o: {correcao['codigo_sugerido']}\")\n        else:\n            print(\"‚úÖ Nenhuma corre√ß√£o espec√≠fica necess√°ria\")\n        \n        return correcoes\n    \n    def escolher_melhor_localizacao_config(self, arquivos_originais: Dict[str, List[str]]) -> Optional[str]:\n        \"\"\"Escolhe a melhor localiza√ß√£o para arquivos de config.\"\"\"\n        config_locs = arquivos_originais.get(\"config/config.yaml\", [])\n        if config_locs:\n            # Priorizar build/lib/cobol_to_docs\n            for loc in config_locs:\n                if \"build/lib/cobol_to_docs\" in loc:\n                    return os.path.dirname(os.path.dirname(loc))  # Subir 2 n√≠veis de config/config.yaml\n            return os.path.dirname(os.path.dirname(config_locs[0]))\n        return None\n    \n    def gerar_relatorio_final(self, analises: List[Dict[str, Any]], correcoes: List[Dict[str, Any]]):\n        \"\"\"Gera relat√≥rio final com resumo.\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"üìä RELAT√ìRIO FINAL DE VALIDA√á√ÉO\")\n        print(\"=\" * 60)\n        \n        # Estat√≠sticas\n        total_arquivos = len([a for a in analises if \"erro\" not in a])\n        arquivos_com_problemas = len([a for a in analises if a.get(\"problemas_encontrados\", [])])\n        total_problemas = sum(len(a.get(\"problemas_encontrados\", [])) for a in analises)\n        \n        print(f\"\\nüìà ESTAT√çSTICAS:\")\n        print(f\"   Arquivos analisados: {total_arquivos}\")\n        print(f\"   Arquivos com problemas: {arquivos_com_problemas}\")\n        print(f\"   Total de problemas: {total_problemas}\")\n        print(f\"   Corre√ß√µes necess√°rias: {len(correcoes)}\")\n        \n        # Problemas mais comuns\n        problemas_comuns = {}\n        for analise in analises:\n            for problema in analise.get(\"problemas_encontrados\", []):\n                problemas_comuns[problema] = problemas_comuns.get(problema, 0) + 1\n        \n        if problemas_comuns:\n            print(f\"\\nüî• PROBLEMAS MAIS COMUNS:\")\n            for problema, count in sorted(problemas_comuns.items(), key=lambda x: x[1], reverse=True):\n                print(f\"   {count}x {problema}\")\n        \n        # Recomenda√ß√µes\n        print(f\"\\nüí° RECOMENDA√á√ïES:\")\n        if total_problemas == 0:\n            print(\"   ‚úÖ Implementa√ß√£o do --init est√° correta!\")\n        elif total_problemas <= 3:\n            print(\"   üîß Poucos problemas encontrados - corre√ß√µes simples\")\n        else:\n            print(\"   üö® Muitos problemas - recomenda-se reescrever fun√ß√£o init\")\n        \n        print(f\"\\nüöÄ PR√ìXIMOS PASSOS:\")\n        print(f\"   1. Aplicar corre√ß√µes listadas acima\")\n        print(f\"   2. Testar comando: mkdir teste && cd teste && cobol-to-docs --init\")\n        print(f\"   3. Verificar se arquivos originais foram copiados\")\n        \n        print(f\"\\n‚úÖ Valida√ß√£o conclu√≠da!\")\n\ndef main():\n    \"\"\"Fun√ß√£o principal do validador.\"\"\"\n    print(\"üîç VALIDADOR DE SOLU√á√ÉO --init\")\n    print(\"Analisa implementa√ß√£o atual e identifica corre√ß√µes necess√°rias\")\n    print(\"=\" * 60)\n    \n    validador = ValidadorInitSolution()\n    \n    # 1. Encontrar arquivos com implementa√ß√£o --init\n    arquivos_init = validador.encontrar_arquivos_com_init()\n    \n    if not arquivos_init:\n        print(\"‚ùå Nenhuma implementa√ß√£o do comando --init encontrada!\")\n        return\n    \n    print(f\"\\n‚úÖ Encontradas {len(arquivos_init)} implementa√ß√µes do --init\")\n    \n    # 2. Analisar cada implementa√ß√£o\n    analises = []\n    for arquivo in arquivos_init:\n        analise = validador.analisar_implementacao_init(arquivo)\n        analises.append(analise)\n    \n    # 3. Mapear arquivos originais\n    arquivos_originais = validador.mapear_arquivos_originais()\n    \n    # 4. Gerar corre√ß√µes espec√≠ficas\n    correcoes = validador.gerar_correcoes_especificas(analises, arquivos_originais)\n    \n    # 5. Relat√≥rio final\n    validador.gerar_relatorio_final(analises, correcoes)\n\nif __name__ == \"__main__\":\n    main()
