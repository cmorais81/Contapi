#!/usr/bin/env python3
"""
Validador de Solução --init
Analisa o código atual do comando --init e identifica exatamente o que precisa ser corrigido
para que a replicação de arquivos funcione corretamente.

Uso:
    python validador_init_solution.py
"""

import os
import sys
import re
import ast
from pathlib import Path
from typing import List, Dict, Any, Optional

class ValidadorInitSolution:
    def __init__(self, caminho_base: str = "."):
        self.caminho_base = os.path.abspath(caminho_base)
        self.detectar_estrutura()
        
        self.problemas_encontrados = []
        self.correcoes_necessarias = []
        self.arquivos_analisados = []
    
    def detectar_estrutura(self):
        """Detecta a estrutura do projeto."""
        for item in os.listdir(self.caminho_base):
            caminho_item = os.path.join(self.caminho_base, item)
            if os.path.isdir(caminho_item) and item == "cobol_to_docs":
                self.caminho_projeto = caminho_item
                self.nome_pacote = "cobol_to_docs"
                return
        
        print("❌ Projeto cobol_to_docs não encontrado!")
        sys.exit(1)
    
    def encontrar_arquivos_com_init(self) -> List[str]:
        """Encontra todos os arquivos que implementam o comando --init."""
        print("🔍 Procurando implementações do comando --init...")
        
        arquivos_com_init = []
        
        # Procurar em runner/
        runner_dir = os.path.join(self.caminho_projeto, "runner")
        if os.path.exists(runner_dir):
            for arquivo in os.listdir(runner_dir):
                if arquivo.endswith('.py'):
                    arquivo_path = os.path.join(runner_dir, arquivo)
                    if self.arquivo_tem_init(arquivo_path):
                        arquivos_com_init.append(arquivo_path)
        
        # Procurar na raiz do projeto
        for arquivo in os.listdir(self.caminho_projeto):
            if arquivo.endswith('.py'):
                arquivo_path = os.path.join(self.caminho_projeto, arquivo)
                if self.arquivo_tem_init(arquivo_path):
                    arquivos_com_init.append(arquivo_path)
        
        return arquivos_com_init
    
    def arquivo_tem_init(self, arquivo_path: str) -> bool:
        """Verifica se um arquivo contém implementação do --init."""
        try:
            with open(arquivo_path, 'r', encoding='utf-8') as f:
                conteudo = f.read()
            
            # Procurar por indicadores de comando --init
            indicadores = [
                '--init',
                'init',
                'inicializar',
                'add_argument.*init',
                'args.init'
            ]
            
            for indicador in indicadores:
                if re.search(indicador, conteudo, re.IGNORECASE):
                    return True
            
            return False
        except Exception:
            return False
    
    def analisar_implementacao_init(self, arquivo_path: str) -> Dict[str, Any]:
        """Analisa a implementação do --init em um arquivo específico."""
        print(f\"\\n📄 Analisando: {os.path.relpath(arquivo_path, self.caminho_base)}\")\n        \n        try:\n            with open(arquivo_path, 'r', encoding='utf-8') as f:\n                conteudo = f.read()\n            \n            analise = {\n                \"arquivo\": arquivo_path,\n                \"tem_argparse_init\": False,\n                \"tem_funcao_init\": False,\n                \"tem_tratamento_args_init\": False,\n                \"problemas_encontrados\": [],\n                \"funcao_init_nome\": None,\n                \"funcao_init_conteudo\": None,\n                \"linhas_problematicas\": []\n            }\n            \n            # 1. Verificar se tem argparse para --init\n            if re.search(r'add_argument.*[\"\\']--init[\"\\']', conteudo):\n                analise[\"tem_argparse_init\"] = True\n                print(\"   ✅ Argparse --init encontrado\")\n            else:\n                analise[\"problemas_encontrados\"].append(\"Falta argparse para --init\")\n                print(\"   ❌ Argparse --init não encontrado\")\n            \n            # 2. Verificar se tem função de inicialização\n            funcoes_init = re.findall(r'def\\s+(\\w*init\\w*)\\s*\\([^)]*\\):', conteudo, re.IGNORECASE)\n            if funcoes_init:\n                analise[\"tem_funcao_init\"] = True\n                analise[\"funcao_init_nome\"] = funcoes_init[0]\n                print(f\"   ✅ Função de inicialização encontrada: {funcoes_init[0]}()\")\n                \n                # Extrair conteúdo da função\n                pattern = rf'def\\s+{funcoes_init[0]}\\s*\\([^)]*\\):.*?(?=\\ndef\\s+|\\nclass\\s+|\\nif\\s+__name__|\\Z)'\n                match = re.search(pattern, conteudo, re.DOTALL)\n                if match:\n                    analise[\"funcao_init_conteudo\"] = match.group(0)\n            else:\n                analise[\"problemas_encontrados\"].append(\"Função de inicialização não encontrada\")\n                print(\"   ❌ Função de inicialização não encontrada\")\n            \n            # 3. Verificar se tem tratamento de args.init\n            if re.search(r'args\\.init', conteudo):\n                analise[\"tem_tratamento_args_init\"] = True\n                print(\"   ✅ Tratamento args.init encontrado\")\n            else:\n                analise[\"problemas_encontrados\"].append(\"Falta tratamento de args.init\")\n                print(\"   ❌ Tratamento args.init não encontrado\")\n            \n            # 4. Analisar problemas específicos na função init\n            if analise[\"funcao_init_conteudo\"]:\n                self.analisar_problemas_funcao_init(analise)\n            \n            return analise\n        \n        except Exception as e:\n            print(f\"   ❌ Erro ao analisar arquivo: {e}\")\n            return {\"arquivo\": arquivo_path, \"erro\": str(e)}\n    \n    def analisar_problemas_funcao_init(self, analise: Dict[str, Any]):\n        \"\"\"Analisa problemas específicos na função de inicialização.\"\"\"\n        conteudo_funcao = analise[\"funcao_init_conteudo\"]\n        problemas = analise[\"problemas_encontrados\"]\n        linhas_problematicas = analise[\"linhas_problematicas\"]\n        \n        print(\"\\n   🔍 Analisando problemas na função de inicialização:\")\n        \n        # Problema 1: Criação de pasta cobol_to_docs duplicada\n        if re.search(r'makedirs.*cobol_to_docs', conteudo_funcao):\n            problemas.append(\"Criando pasta cobol_to_docs duplicada\")\n            linhas = self.encontrar_linhas_problema(conteudo_funcao, r'makedirs.*cobol_to_docs')\n            linhas_problematicas.extend(linhas)\n            print(\"     ❌ Criando pasta cobol_to_docs duplicada\")\n        \n        # Problema 2: Caminhos hardcoded\n        if re.search(r'[\"\\'][./]*cobol_to_docs[\"\\']', conteudo_funcao):\n            problemas.append(\"Caminhos hardcoded para cobol_to_docs\")\n            linhas = self.encontrar_linhas_problema(conteudo_funcao, r'[\"\\'][./]*cobol_to_docs[\"\\']')\n            linhas_problematicas.extend(linhas)\n            print(\"     ❌ Caminhos hardcoded para cobol_to_docs\")\n        \n        # Problema 3: Não detecta localização do pacote instalado\n        if not re.search(r'__file__|import.*cobol_to_docs|find.*package', conteudo_funcao):\n            problemas.append(\"Não detecta localização do pacote instalado\")\n            print(\"     ❌ Não detecta localização do pacote instalado\")\n        \n        # Problema 4: Não copia arquivos originais\n        if not re.search(r'copy|shutil', conteudo_funcao):\n            problemas.append(\"Não copia arquivos originais\")\n            print(\"     ❌ Não copia arquivos originais\")\n        \n        # Problema 5: Cria apenas estrutura básica\n        if re.search(r'open.*config.*w', conteudo_funcao) and not re.search(r'copy.*config', conteudo_funcao):\n            problemas.append(\"Cria config padrão em vez de copiar original\")\n            print(\"     ❌ Cria config padrão em vez de copiar original\")\n        \n        # Problema 6: Não verifica múltiplas localizações\n        if not re.search(r'build|lib|dist', conteudo_funcao):\n            problemas.append(\"Não verifica localizações em build/lib/\")\n            print(\"     ❌ Não verifica localizações em build/lib/\")\n        \n        # Verificar se tem tratamento de erro\n        if not re.search(r'try:|except:|Exception', conteudo_funcao):\n            problemas.append(\"Falta tratamento de erros\")\n            print(\"     ⚠️  Falta tratamento de erros\")\n        \n        # Verificar se cria subpastas necessárias\n        subpastas_necessarias = ['embeddings', 'knowledge_base', 'sessions']\n        for subpasta in subpastas_necessarias:\n            if subpasta not in conteudo_funcao:\n                problemas.append(f\"Não cria subpasta {subpasta}\")\n                print(f\"     ⚠️  Não cria subpasta {subpasta}\")\n    \n    def encontrar_linhas_problema(self, conteudo: str, pattern: str) -> List[str]:\n        \"\"\"Encontra linhas que contêm padrões problemáticos.\"\"\"\n        linhas_problema = []\n        \n        try:\n            matches = re.finditer(pattern, conteudo)\n            for match in matches:\n                # Encontrar número da linha\n                linha_inicio = conteudo[:match.start()].count('\\n') + 1\n                linha_conteudo = conteudo.split('\\n')[linha_inicio - 1].strip()\n                linhas_problema.append(f\"Linha {linha_inicio}: {linha_conteudo}\")\n        except Exception:\n            pass\n        \n        return linhas_problema\n    \n    def mapear_arquivos_originais(self) -> Dict[str, List[str]]:\n        \"\"\"Mapeia onde estão os arquivos originais que deveriam ser copiados.\"\"\"\n        print(\"\\n🗺️  Mapeando arquivos originais que deveriam ser copiados...\")\n        \n        # Locais para procurar\n        locais_busca = [\n            os.path.join(self.caminho_base, \"build\", \"lib\", \"cobol_to_docs\"),\n            self.caminho_projeto,\n            os.path.join(self.caminho_base, \"build\"),\n        ]\n        \n        # Arquivos importantes\n        arquivos_importantes = {\n            \"config/config.yaml\": [],\n            \"config/config_enhanced.yaml\": [],\n            \"config/prompts_enhanced.yaml\": [],\n            \"data/cobol_knowledge_base.json\": [],\n            \"data/cobol_knowledge_base_consolidated.json\": [],\n            \"examples/*.cbl\": [],\n        }\n        \n        for local in locais_busca:\n            if os.path.exists(local):\n                print(f\"   Procurando em: {os.path.relpath(local, self.caminho_base)}\")\n                \n                for arquivo_pattern, localizacoes in arquivos_importantes.items():\n                    if \"*\" in arquivo_pattern:\n                        # Padrão com wildcard\n                        import glob\n                        pasta, pattern = arquivo_pattern.split(\"/\")\n                        pasta_completa = os.path.join(local, pasta)\n                        if os.path.exists(pasta_completa):\n                            arquivos_encontrados = glob.glob(os.path.join(pasta_completa, pattern))\n                            localizacoes.extend(arquivos_encontrados)\n                    else:\n                        # Arquivo específico\n                        arquivo_path = os.path.join(local, arquivo_pattern)\n                        if os.path.exists(arquivo_path):\n                            localizacoes.append(arquivo_path)\n        \n        # Mostrar resultados\n        print(\"\\n📋 Arquivos originais encontrados:\")\n        for arquivo, localizacoes in arquivos_importantes.items():\n            if localizacoes:\n                print(f\"   ✅ {arquivo} ({len(localizacoes)} locais)\")\n                for loc in localizacoes[:2]:  # Mostrar apenas os 2 primeiros\n                    print(f\"      • {os.path.relpath(loc, self.caminho_base)}\")\n                if len(localizacoes) > 2:\n                    print(f\"      ... e mais {len(localizacoes) - 2}\")\n            else:\n                print(f\"   ❌ {arquivo} - NÃO ENCONTRADO\")\n        \n        return arquivos_importantes\n    \n    def gerar_correcoes_especificas(self, analises: List[Dict[str, Any]], arquivos_originais: Dict[str, List[str]]):\n        \"\"\"Gera lista de correções específicas necessárias.\"\"\"\n        print(\"\\n🔧 CORREÇÕES ESPECÍFICAS NECESSÁRIAS:\")\n        print(\"=\" * 60)\n        \n        correcoes = []\n        \n        # Correções baseadas na análise\n        for analise in analises:\n            if \"erro\" in analise:\n                continue\n            \n            arquivo_rel = os.path.relpath(analise[\"arquivo\"], self.caminho_base)\n            \n            for problema in analise[\"problemas_encontrados\"]:\n                if \"Falta argparse\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"argparse\",\n                        \"descricao\": \"Adicionar argparse para --init\",\n                        \"codigo_sugerido\": 'parser.add_argument(\"--init\", action=\"store_true\", help=\"Inicializar ambiente\")'\n                    })\n                \n                elif \"Função de inicialização não encontrada\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"funcao\",\n                        \"descricao\": \"Criar função de inicialização\",\n                        \"codigo_sugerido\": \"def inicializar_ambiente(diretorio_trabalho='.'):\"\n                    })\n                \n                elif \"Falta tratamento de args.init\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"tratamento\",\n                        \"descricao\": \"Adicionar tratamento de args.init\",\n                        \"codigo_sugerido\": \"if args.init:\\n    inicializar_ambiente()\\n    sys.exit(0)\"\n                    })\n                \n                elif \"pasta cobol_to_docs duplicada\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"caminho\",\n                        \"descricao\": \"Remover criação de pasta duplicada\",\n                        \"codigo_sugerido\": \"# Criar estrutura no diretório atual, não em subpasta\"\n                    })\n                \n                elif \"Não detecta localização do pacote\" in problema:\n                    melhor_localizacao = self.escolher_melhor_localizacao_config(arquivos_originais)\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"deteccao\",\n                        \"descricao\": \"Adicionar detecção de localização do pacote\",\n                        \"codigo_sugerido\": f\"# Detectar em: {melhor_localizacao if melhor_localizacao else 'build/lib/cobol_to_docs'}\"\n                    })\n                \n                elif \"Não copia arquivos originais\" in problema:\n                    correcoes.append({\n                        \"arquivo\": arquivo_rel,\n                        \"tipo\": \"copia\",\n                        \"descricao\": \"Adicionar cópia de arquivos originais\",\n                        \"codigo_sugerido\": \"shutil.copy2(arquivo_origem, arquivo_destino)\"\n                    })\n        \n        # Mostrar correções\n        if correcoes:\n            for i, correcao in enumerate(correcoes, 1):\n                print(f\"\\n{i}. {correcao['descricao']}\")\n                print(f\"   📄 Arquivo: {correcao['arquivo']}\")\n                print(f\"   🔧 Tipo: {correcao['tipo']}\")\n                print(f\"   💡 Sugestão: {correcao['codigo_sugerido']}\")\n        else:\n            print(\"✅ Nenhuma correção específica necessária\")\n        \n        return correcoes\n    \n    def escolher_melhor_localizacao_config(self, arquivos_originais: Dict[str, List[str]]) -> Optional[str]:\n        \"\"\"Escolhe a melhor localização para arquivos de config.\"\"\"\n        config_locs = arquivos_originais.get(\"config/config.yaml\", [])\n        if config_locs:\n            # Priorizar build/lib/cobol_to_docs\n            for loc in config_locs:\n                if \"build/lib/cobol_to_docs\" in loc:\n                    return os.path.dirname(os.path.dirname(loc))  # Subir 2 níveis de config/config.yaml\n            return os.path.dirname(os.path.dirname(config_locs[0]))\n        return None\n    \n    def gerar_relatorio_final(self, analises: List[Dict[str, Any]], correcoes: List[Dict[str, Any]]):\n        \"\"\"Gera relatório final com resumo.\"\"\"\n        print(\"\\n\" + \"=\" * 60)\n        print(\"📊 RELATÓRIO FINAL DE VALIDAÇÃO\")\n        print(\"=\" * 60)\n        \n        # Estatísticas\n        total_arquivos = len([a for a in analises if \"erro\" not in a])\n        arquivos_com_problemas = len([a for a in analises if a.get(\"problemas_encontrados\", [])])\n        total_problemas = sum(len(a.get(\"problemas_encontrados\", [])) for a in analises)\n        \n        print(f\"\\n📈 ESTATÍSTICAS:\")\n        print(f\"   Arquivos analisados: {total_arquivos}\")\n        print(f\"   Arquivos com problemas: {arquivos_com_problemas}\")\n        print(f\"   Total de problemas: {total_problemas}\")\n        print(f\"   Correções necessárias: {len(correcoes)}\")\n        \n        # Problemas mais comuns\n        problemas_comuns = {}\n        for analise in analises:\n            for problema in analise.get(\"problemas_encontrados\", []):\n                problemas_comuns[problema] = problemas_comuns.get(problema, 0) + 1\n        \n        if problemas_comuns:\n            print(f\"\\n🔥 PROBLEMAS MAIS COMUNS:\")\n            for problema, count in sorted(problemas_comuns.items(), key=lambda x: x[1], reverse=True):\n                print(f\"   {count}x {problema}\")\n        \n        # Recomendações\n        print(f\"\\n💡 RECOMENDAÇÕES:\")\n        if total_problemas == 0:\n            print(\"   ✅ Implementação do --init está correta!\")\n        elif total_problemas <= 3:\n            print(\"   🔧 Poucos problemas encontrados - correções simples\")\n        else:\n            print(\"   🚨 Muitos problemas - recomenda-se reescrever função init\")\n        \n        print(f\"\\n🚀 PRÓXIMOS PASSOS:\")\n        print(f\"   1. Aplicar correções listadas acima\")\n        print(f\"   2. Testar comando: mkdir teste && cd teste && cobol-to-docs --init\")\n        print(f\"   3. Verificar se arquivos originais foram copiados\")\n        \n        print(f\"\\n✅ Validação concluída!\")\n\ndef main():\n    \"\"\"Função principal do validador.\"\"\"\n    print(\"🔍 VALIDADOR DE SOLUÇÃO --init\")\n    print(\"Analisa implementação atual e identifica correções necessárias\")\n    print(\"=\" * 60)\n    \n    validador = ValidadorInitSolution()\n    \n    # 1. Encontrar arquivos com implementação --init\n    arquivos_init = validador.encontrar_arquivos_com_init()\n    \n    if not arquivos_init:\n        print(\"❌ Nenhuma implementação do comando --init encontrada!\")\n        return\n    \n    print(f\"\\n✅ Encontradas {len(arquivos_init)} implementações do --init\")\n    \n    # 2. Analisar cada implementação\n    analises = []\n    for arquivo in arquivos_init:\n        analise = validador.analisar_implementacao_init(arquivo)\n        analises.append(analise)\n    \n    # 3. Mapear arquivos originais\n    arquivos_originais = validador.mapear_arquivos_originais()\n    \n    # 4. Gerar correções específicas\n    correcoes = validador.gerar_correcoes_especificas(analises, arquivos_originais)\n    \n    # 5. Relatório final\n    validador.gerar_relatorio_final(analises, correcoes)\n\nif __name__ == \"__main__\":\n    main()
