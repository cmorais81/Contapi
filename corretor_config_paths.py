#!/usr/bin/env python3
"""
Corretor de Caminhos de Configura√ß√£o - Corrige localiza√ß√£o de arquivos config/data
Resolve problemas de localiza√ß√£o de arquivos ap√≥s mudan√ßa de estrutura do projeto.

Uso:
    python corretor_config_paths.py                    # Corre√ß√£o interativa
    python corretor_config_paths.py --auto             # Corre√ß√£o autom√°tica
    python corretor_config_paths.py --mapear           # Mapear localiza√ß√µes
"""

import os
import sys
import re
import shutil
import argparse
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

class CorretorConfigPaths:
    def __init__(self, caminho_base: str = ".", modo_auto: bool = False):
        self.caminho_base = os.path.abspath(caminho_base)
        self.modo_auto = modo_auto
        
        # Detectar estrutura
        self.detectar_estrutura()
        
        self.localizacoes_encontradas = {}
        self.correcoes_aplicadas = []
        self.backup_criado = False
    
    def detectar_estrutura(self):
        """Detecta a estrutura do projeto."""
        for item in os.listdir(self.caminho_base):
            caminho_item = os.path.join(self.caminho_base, item)
            if os.path.isdir(caminho_item) and item == "cobol_to_docs":
                self.caminho_projeto = caminho_item
                self.nome_pacote = "cobol_to_docs"
                return
        
        print("‚ùå Projeto cobol_to_docs n√£o encontrado!")
        sys.exit(1)
    
    def criar_backup(self):
        """Cria backup do projeto."""
        if self.backup_criado:
            return True
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = f"{self.caminho_projeto}_backup_paths_{timestamp}"
        
        try:
            shutil.copytree(self.caminho_projeto, backup_dir)
            print(f"‚úÖ Backup criado: {os.path.basename(backup_dir)}")
            self.backup_criado = True
            return True
        except Exception as e:
            print(f"‚ùå Erro ao criar backup: {e}")
            return False
    
    def perguntar_usuario(self, pergunta: str, default: str = "s") -> bool:
        """Pergunta algo ao usu√°rio se n√£o estiver em modo autom√°tico."""
        if self.modo_auto:
            return True
        
        resposta = input(f"{pergunta} [{default}/n]: ").strip().lower()
        return resposta in ['', 's', 'sim', 'y', 'yes']
    
    def mapear_localizacoes_arquivos(self):
        """Mapeia onde est√£o os arquivos de configura√ß√£o e dados."""
        print("\nüîç Mapeando localiza√ß√µes de arquivos de configura√ß√£o e dados...")
        
        # Locais poss√≠veis para procurar
        locais_busca = [
            self.caminho_base,  # Raiz do projeto
            self.caminho_projeto,  # cobol_to_docs/
            os.path.join(self.caminho_base, "build"),  # build/
            os.path.join(self.caminho_base, "build", "lib"),  # build/lib/
            os.path.join(self.caminho_base, "build", "lib", "cobol_to_docs"),  # build/lib/cobol_to_docs/
        ]
        
        # Arquivos importantes para encontrar\n        arquivos_importantes = {\n            \"config.yaml\": [],\n            \"config_enhanced.yaml\": [],\n            \"prompts_cadoc_deep_analysis.yaml\": [],\n            \"prompts_deep_business_rules.yaml\": [],\n            \"prompts_doc_legado_pro.yaml\": [],\n            \"prompts_enhanced.yaml\": [],\n            \"prompts_especialista.yaml\": [],\n            \"prompts_melhorado_rag.yaml\": [],\n            \"cobol_knowledge_base.json\": [],\n            \"cobol_knowledge_base_consolidated.json\": []\n        }\n        \n        # Buscar arquivos em todos os locais\n        for local in locais_busca:\n            if os.path.exists(local):\n                self.buscar_arquivos_recursivo(local, arquivos_importantes)\n        \n        # Mostrar resultados\n        print(\"\\nüìã MAPEAMENTO DE ARQUIVOS:\")\n        for arquivo, localizacoes in arquivos_importantes.items():\n            if localizacoes:\n                print(f\"\\nüìÑ {arquivo}:\")\n                for i, loc in enumerate(localizacoes):\n                    relativo = os.path.relpath(loc, self.caminho_base)\n                    print(f\"   {i+1}. {relativo}\")\n            else:\n                print(f\"\\n‚ùå {arquivo}: N√ÉO ENCONTRADO\")\n        \n        self.localizacoes_encontradas = arquivos_importantes\n        return arquivos_importantes\n    \n    def buscar_arquivos_recursivo(self, diretorio: str, arquivos_importantes: Dict[str, List[str]]):\n        \"\"\"Busca arquivos recursivamente em um diret√≥rio.\"\"\"\n        try:\n            for raiz, dirs, arquivos in os.walk(diretorio):\n                # Pular diret√≥rios desnecess√°rios\n                dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules']]\n                \n                for arquivo in arquivos:\n                    if arquivo in arquivos_importantes:\n                        caminho_completo = os.path.join(raiz, arquivo)\n                        arquivos_importantes[arquivo].append(caminho_completo)\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Erro ao buscar em {diretorio}: {e}\")\n    \n    def escolher_melhor_localizacao(self, arquivo: str, localizacoes: List[str]) -> Optional[str]:\n        \"\"\"Escolhe a melhor localiza√ß√£o para um arquivo.\"\"\"\n        if not localizacoes:\n            return None\n        \n        # Prioridades (ordem de prefer√™ncia)\n        prioridades = [\n            \"build/lib/cobol_to_docs\",  # Vers√£o instalada\n            \"cobol_to_docs\",           # Vers√£o de desenvolvimento\n            \"build\",                   # Build\n        ]\n        \n        for prioridade in prioridades:\n            for loc in localizacoes:\n                if prioridade in loc:\n                    return loc\n        \n        # Se n√£o encontrar por prioridade, retornar o primeiro\n        return localizacoes[0]\n    \n    def gerar_funcao_init_corrigida(self) -> str:\n        \"\"\"Gera fun√ß√£o de inicializa√ß√£o com caminhos corretos.\"\"\"\n        \n        # Escolher melhores localiza√ß√µes\n        config_path = self.escolher_melhor_localizacao(\"config.yaml\", \n                                                      self.localizacoes_encontradas.get(\"config.yaml\", []))\n        \n        knowledge_base_path = self.escolher_melhor_localizacao(\"cobol_knowledge_base.json\",\n                                                              self.localizacoes_encontradas.get(\"cobol_knowledge_base.json\", []))\n        \n        return f'''def inicializar_ambiente(diretorio_trabalho=\".\"):\n    \"\"\"\n    Inicializa ambiente de trabalho para an√°lise COBOL.\n    Corrigido para encontrar arquivos na nova estrutura.\n    \n    Args:\n        diretorio_trabalho (str): Diret√≥rio onde criar a estrutura de trabalho\n    \n    Returns:\n        bool: True se inicializa√ß√£o foi bem-sucedida\n    \"\"\"\n    import os\n    import shutil\n    from pathlib import Path\n    import sys\n    \n    diretorio_trabalho = Path(diretorio_trabalho).resolve()\n    \n    print(f\"üîß Inicializando ambiente em: {{diretorio_trabalho}}\")\n    \n    # Detectar localiza√ß√£o dos arquivos de configura√ß√£o\n    locais_poss√≠veis = [\n        # Tentar localiza√ß√£o do pacote instalado\n        Path(__file__).parent.parent,  # Subir dois n√≠veis do runner\n        Path(__file__).parent.parent.parent,  # Subir tr√™s n√≠veis\n        \n        # Localiza√ß√µes espec√≠ficas baseadas no mapeamento\n        Path(\"{os.path.dirname(config_path) if config_path else 'config'}\"),\n        Path(\"{os.path.dirname(knowledge_base_path) if knowledge_base_path else 'data'}\"),\n        \n        # Localiza√ß√µes de fallback\n        Path(\"build/lib/cobol_to_docs\"),\n        Path(\"cobol_to_docs\"),\n        Path(\".\"),\n    ]\n    \n    # Encontrar diret√≥rio base com arquivos de configura√ß√£o\n    diretorio_base = None\n    for local in locais_poss√≠veis:\n        if local.exists():\n            # Verificar se tem config ou data\n            if (local / \"config\").exists() or (local / \"data\").exists():\n                diretorio_base = local\n                print(f\"üìÅ Arquivos de configura√ß√£o encontrados em: {{local}}\")\n                break\n    \n    if not diretorio_base:\n        print(\"‚ö†Ô∏è  N√£o foi poss√≠vel encontrar arquivos de configura√ß√£o originais\")\n        print(\"   Criando estrutura b√°sica...\")\n        diretorio_base = None\n    \n    # Estrutura de diret√≥rios para criar\n    estrutura_diretorios = [\n        \"config\",\n        \"data\",\n        \"data/embeddings\", \n        \"data/knowledge_base\",\n        \"data/sessions\",\n        \"logs\",\n        \"examples\",\n        \"output\",\n        \"input\"\n    ]\n    \n    # Criar estrutura de diret√≥rios\n    for diretorio in estrutura_diretorios:\n        dir_path = diretorio_trabalho / diretorio\n        dir_path.mkdir(parents=True, exist_ok=True)\n        print(f\"‚úÖ Diret√≥rio: {{diretorio}}\")\n    \n    # Copiar arquivos de configura√ß√£o se encontrados\n    if diretorio_base:\n        arquivos_para_copiar = [\n            (\"config\", [\"config.yaml\", \"config_enhanced.yaml\", \"prompts_*.yaml\"]),\n            (\"data\", [\"cobol_knowledge_base.json\", \"cobol_knowledge_base_consolidated.json\"]),\n            (\"examples\", [\"*.cbl\", \"*.cob\", \"*.cobol\"]),\n        ]\n        \n        for pasta, patterns in arquivos_para_copiar:\n            pasta_origem = diretorio_base / pasta\n            pasta_destino = diretorio_trabalho / pasta\n            \n            if pasta_origem.exists():\n                for pattern in patterns:\n                    if \"*\" in pattern:\n                        import glob\n                        arquivos_encontrados = glob.glob(str(pasta_origem / pattern))\n                        for arquivo_origem in arquivos_encontrados:\n                            arquivo_nome = Path(arquivo_origem).name\n                            arquivo_destino = pasta_destino / arquivo_nome\n                            \n                            try:\n                                shutil.copy2(arquivo_origem, arquivo_destino)\n                                print(f\"‚úÖ Copiado: {{pasta}}/{{arquivo_nome}}\")\n                            except Exception as e:\n                                print(f\"‚ö†Ô∏è  Erro ao copiar {{arquivo_origem}}: {{e}}\")\n                    else:\n                        arquivo_origem = pasta_origem / pattern\n                        arquivo_destino = pasta_destino / pattern\n                        \n                        if arquivo_origem.exists():\n                            try:\n                                shutil.copy2(arquivo_origem, arquivo_destino)\n                                print(f\"‚úÖ Copiado: {{pasta}}/{{pattern}}\")\n                            except Exception as e:\n                                print(f\"‚ö†Ô∏è  Erro ao copiar {{arquivo_origem}}: {{e}}\")\n    \n    # Criar configura√ß√£o b√°sica se n√£o foi copiada\n    config_local = diretorio_trabalho / \"config\" / \"config.yaml\"\n    if not config_local.exists():\n        config_conteudo = '''# Configura√ß√£o COBOL Analyzer - Gerada automaticamente\n# Baseada na nova estrutura do projeto\n\n# Configura√ß√µes de an√°lise\nanalysis:\n  output_format: \"markdown\"\n  include_comments: true\n  generate_diagrams: true\n  deep_analysis: true\n\n# Configura√ß√µes de caminhos\npaths:\n  input_dir: \"./input\"\n  output_dir: \"./output\"\n  logs_dir: \"./logs\"\n  data_dir: \"./data\"\n\n# Configura√ß√µes de IA\nai:\n  model: \"default\"\n  temperature: 0.7\n  max_tokens: 2000\n  use_enhanced_prompts: true\n\n# Configura√ß√µes de documenta√ß√£o\ndocumentation:\n  language: \"pt-BR\"\n  include_examples: true\n  generate_index: true\n  include_business_rules: true\n  legacy_documentation: true\n\n# Configura√ß√µes RAG (Retrieval Augmented Generation)\nrag:\n  enabled: true\n  knowledge_base: \"./data/cobol_knowledge_base.json\"\n  embeddings_dir: \"./data/embeddings\"\n  chunk_size: 1000\n  overlap: 200\n'''\n        \n        try:\n            with open(config_local, 'w', encoding='utf-8') as f:\n                f.write(config_conteudo)\n            print(f\"‚úÖ Configura√ß√£o criada: config/config.yaml\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  Erro ao criar configura√ß√£o: {{e}}\")\n    \n    # Criar marcador de inicializa√ß√£o\n    marker_file = diretorio_trabalho / \".cobol_analyzer_init\"\n    try:\n        with open(marker_file, 'w', encoding='utf-8') as f:\n            f.write(f\"Inicializado em: {{datetime.now().isoformat()}}\\\\n\")\n            f.write(f\"Estrutura corrigida: True\\\\n\")\n            f.write(f\"Arquivos base encontrados: {{diretorio_base is not None}}\\\\n\")\n        print(f\"‚úÖ Marcador: .cobol_analyzer_init\")\n    except Exception as e:\n        print(f\"‚ö†Ô∏è  Erro ao criar marcador: {{e}}\")\n    \n    print(f\"\\\\nüéâ Ambiente inicializado com sucesso!\")\n    print(f\"üìÅ Diret√≥rio: {{diretorio_trabalho}}\")\n    print(f\"üìã Arquivos originais: {{'Encontrados' if diretorio_base else 'Criados padr√£o'}}\")\n    \n    print(f\"\\\\nüöÄ Pr√≥ximos passos:\")\n    print(f\"   1. Coloque arquivos COBOL em: ./input/\")\n    print(f\"   2. Execute: cobol-to-docs --analyze ./input\")\n    print(f\"   3. Verifique resultados em: ./output/\")\n    \n    return True'''\n    \n    def corrigir_arquivo_main_cli(self, arquivo_path: str) -> bool:\n        \"\"\"Corrige arquivo main.py ou cli.py com nova fun√ß√£o init.\"\"\"\n        try:\n            with open(arquivo_path, 'r', encoding='utf-8') as f:\n                conteudo = f.read()\n            \n            conteudo_original = conteudo\n            \n            # Remover fun√ß√£o init antiga\n            conteudo = re.sub(\n                r'def\\s+inicializar_ambiente.*?(?=def\\s+|\\Z)',\n                '',\n                conteudo,\n                flags=re.DOTALL\n            )\n            \n            # Adicionar nova fun√ß√£o init\n            nova_funcao = self.gerar_funcao_init_corrigida()\n            \n            # Encontrar local para inserir (antes da fun√ß√£o main)\n            if 'def main(' in conteudo:\n                conteudo = conteudo.replace('def main(', f'{nova_funcao}\\n\\ndef main(')\n            else:\n                # Adicionar no final\n                conteudo += f'\\n\\n{nova_funcao}'\n            \n            # Corrigir imports se necess√°rio\n            if 'from datetime import datetime' not in conteudo:\n                if 'import' in conteudo:\n                    # Adicionar ap√≥s outros imports\n                    linhas = conteudo.split('\\n')\n                    insert_pos = 0\n                    for i, linha in enumerate(linhas):\n                        if linha.strip().startswith('import ') or linha.strip().startswith('from '):\n                            insert_pos = i + 1\n                    \n                    linhas.insert(insert_pos, 'from datetime import datetime')\n                    conteudo = '\\n'.join(linhas)\n            \n            if conteudo != conteudo_original:\n                if not self.criar_backup():\n                    return False\n                \n                with open(arquivo_path, 'w', encoding='utf-8') as f:\n                    f.write(conteudo)\n                \n                return True\n            \n            return False\n        \n        except Exception as e:\n            print(f\"‚ùå Erro ao corrigir {arquivo_path}: {e}\")\n            return False\n    \n    def executar_correcoes(self, apenas_mapear: bool = False):\n        \"\"\"Executa corre√ß√µes de caminhos de configura√ß√£o.\"\"\"\n        print(\"üîß CORRETOR DE CAMINHOS DE CONFIGURA√á√ÉO\")\n        print(\"=\" * 60)\n        print(f\"üìÅ Projeto: {self.nome_pacote}\")\n        print(f\"üìç Localiza√ß√£o: {self.caminho_projeto}\")\n        \n        if apenas_mapear:\n            print(\"üó∫Ô∏è  MODO: Apenas mapeamento\")\n        elif self.modo_auto:\n            print(\"ü§ñ MODO: Corre√ß√£o autom√°tica\")\n        else:\n            print(\"ü§ù MODO: Corre√ß√£o interativa\")\n        \n        # Mapear localiza√ß√µes\n        self.mapear_localizacoes_arquivos()\n        \n        if apenas_mapear:\n            return\n        \n        # Verificar se encontrou arquivos importantes\n        config_encontrado = bool(self.localizacoes_encontradas.get(\"config.yaml\", []))\n        data_encontrado = bool(self.localizacoes_encontradas.get(\"cobol_knowledge_base.json\", []))\n        \n        if not config_encontrado and not data_encontrado:\n            print(\"\\n‚ö†Ô∏è  ATEN√á√ÉO: Nenhum arquivo de configura√ß√£o ou dados encontrado!\")\n            print(\"   A fun√ß√£o init ser√° criada com configura√ß√µes padr√£o.\")\n        \n        if self.perguntar_usuario(\"Corrigir fun√ß√£o de inicializa√ß√£o com caminhos corretos?\"):\n            # Corrigir arquivos principais\n            arquivos_principais = [\n                os.path.join(self.caminho_projeto, \"runner\", \"main.py\"),\n                os.path.join(self.caminho_projeto, \"runner\", \"cli.py\"),\n            ]\n            \n            arquivos_corrigidos = 0\n            for arquivo_path in arquivos_principais:\n                if os.path.exists(arquivo_path):\n                    if self.corrigir_arquivo_main_cli(arquivo_path):\n                        arquivo_rel = os.path.relpath(arquivo_path, self.caminho_base)\n                        print(f\"‚úÖ Corrigido: {arquivo_rel}\")\n                        self.correcoes_aplicadas.append(f\"Fun√ß√£o init corrigida em {arquivo_rel}\")\n                        arquivos_corrigidos += 1\n            \n            if arquivos_corrigidos == 0:\n                print(\"‚ÑπÔ∏è  Nenhum arquivo precisou de corre√ß√£o\")\n        \n        # Relat√≥rio final\n        print(\"\\n\" + \"=\" * 60)\n        print(\"üìã RESUMO\")\n        print(\"=\" * 60)\n        \n        if self.correcoes_aplicadas:\n            print(f\"‚úÖ {len(self.correcoes_aplicadas)} corre√ß√µes aplicadas:\")\n            for correcao in self.correcoes_aplicadas:\n                print(f\"   ‚Ä¢ {correcao}\")\n        else:\n            print(\"‚ÑπÔ∏è  Nenhuma corre√ß√£o foi aplicada\")\n        \n        if self.backup_criado:\n            print(f\"\\nüíæ Backup de seguran√ßa criado\")\n        \n        print(f\"\\nüß™ TESTE RECOMENDADO:\")\n        print(f\"   mkdir teste_init_corrigido && cd teste_init_corrigido\")\n        print(f\"   cobol-to-docs --init\")\n        print(f\"   ls -la  # Verificar se arquivos originais foram copiados\")\n        \n        print(f\"\\n‚úÖ Corre√ß√£o de caminhos conclu√≠da!\")\n\ndef main():\n    \"\"\"Fun√ß√£o principal.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Corretor de Caminhos de Configura√ß√£o\")\n    parser.add_argument(\"--auto\", action=\"store_true\", \n                       help=\"Modo autom√°tico\")\n    parser.add_argument(\"--mapear\", action=\"store_true\",\n                       help=\"Apenas mapear localiza√ß√µes dos arquivos\")\n    \n    args = parser.parse_args()\n    \n    corretor = CorretorConfigPaths(modo_auto=args.auto)\n    corretor.executar_correcoes(apenas_mapear=args.mapear)\n\nif __name__ == \"__main__\":\n    main()
